name: Monitor Eventim F1 (Telegram)

on:
  schedule:
    - cron: "*/5 * * * *"      # a cada 5 min
  workflow_dispatch:            # rodar manualmente
    inputs:
      force_notify:
        description: "Enviar notifica√ß√£o de teste agora?"
        required: false
        default: "false"
  push:                         # tamb√©m roda quando voc√™ editar este arquivo
    branches: [ main ]

permissions:
  contents: write               # para salvar/atualizar arquivos de estado se quiser

jobs:
  check:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps (Playwright + Requests)
        run: |
          python -m pip install --upgrade pip
          pip install playwright requests
          python -m playwright install --with-deps

      - name: Run monitor (robusto com m√∫ltiplos fallbacks)
        id: monitor
        env:
          BOT_TOKEN: ${{ secrets.BOT_TOKEN }}
          CHAT_ID: ${{ secrets.CHAT_ID }}
          FORCE_NOTIFY: ${{ github.event.inputs.force_notify }}
        run: |
          python - << 'PY'
          import asyncio, os, re, requests
          from playwright.async_api import async_playwright

          URL = "https://www.eventim.com.br/campaign/f1saopaulo"
          TARGET_WORDS = [r"comprar", r"buy", r"ticket", r"tickets"]

          BOT_TOKEN = os.environ["BOT_TOKEN"]
          CHAT_ID   = os.environ["CHAT_ID"]
          FORCE     = (os.environ.get("FORCE_NOTIFY","false").lower() == "true")

          UA = ("Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 "
                "(KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36")
          HDRS = {
            "User-Agent": UA,
            "Accept-Language": "pt-BR,pt;q=0.9,en-US;q=0.8,en;q=0.7",
            "Cache-Control": "no-cache",
          }

          def gh_set_output(key, val):
            with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as out:
              print(f"{key}={val}", file=out)

          def simple_parse(html: str) -> bool:
            return any(re.search(pat, html, flags=re.I) for pat in TARGET_WORDS)

          def fallback_requests() -> bool:
            try:
              r = requests.get(URL, headers=HDRS, timeout=30, allow_redirects=True)
              if r.status_code == 200 and r.text:
                return simple_parse(r.text)
            except Exception:
              pass
            return False

          async def try_engine(p, engine_name: str) -> bool:
            # engine_name: "chromium" | "firefox" | "webkit"
            launch_args = []
            context_kwargs = dict(
              user_agent=UA,
              locale="pt-BR",
              extra_http_headers={"Accept-Language": HDRS["Accept-Language"]},
              ignore_https_errors=True,
              viewport={"width": 1366, "height": 768},
            )

            if engine_name == "chromium":
              # Desabilita HTTP/2 para evitar ERR_HTTP2_PROTOCOL_ERROR
              launch_args = ["--disable-http2", "--no-sandbox", "--disable-dev-shm-usage"]
              browser = await p.chromium.launch(headless=True, args=launch_args)
            elif engine_name == "firefox":
              browser = await p.firefox.launch(headless=True)
            else:
              browser = await p.webkit.launch(headless=True)

            context = await browser.new_context(**context_kwargs)
            page = await context.new_page()

            # 1) Primeiro tenta carregar at√© DOMContentLoaded (r√°pido e mais compat√≠vel)
            try:
              await page.goto(URL, wait_until="domcontentloaded", timeout=90_000)
            except Exception:
              await browser.close()
              return False

            # 2) Tenta networkidle, mas SEM falhar se n√£o conseguir
            try:
              await page.wait_for_load_state("networkidle", timeout=20_000)
            except Exception:
              pass

            html = await page.content()
            has_text = simple_parse(html)

            enabled = False
            for sel in ["button", "a[role=button]", "a"]:
              els = await page.locator(sel).all()
              for el in els:
                try:
                  txt = (await el.inner_text()).strip().lower()
                except Exception:
                  continue
                if any(w in txt for w in ["comprar","buy","ticket","tickets"]):
                  disabled = await el.get_attribute("disabled")
                  aria     = await el.get_attribute("aria-disabled")
                  classes  = (await el.get_attribute("class") or "").lower()
                  if (disabled is None) and (aria in [None,"false"]) and ("disabled" not in classes):
                    enabled = True
                    break
              if enabled:
                break

            await browser.close()
            return has_text or enabled

          async def detect():
            # Tenta Chromium (com HTTP/2 off) ‚Üí Firefox ‚Üí WebKit ‚Üí Requests
            async with async_playwright() as p:
              for engine in ("chromium", "firefox", "webkit"):
                try:
                  ok = await try_engine(p, engine)
                  if ok:
                    return True
                except Exception:
                  # tenta pr√≥ximo engine
                  pass
            # √∫ltimo recurso: requests (pode n√£o ver conte√∫do renderizado em JS, mas evita quebrar)
            return fallback_requests()

          async def main():
            if FORCE:
              gh_set_output("should_notify", "true")
              return
            is_on = await detect()
            gh_set_output("should_notify", "true" if is_on else "false")

          asyncio.run(main())
          PY

      - name: Send Telegram notification
        if: steps.monitor.outputs.should_notify == 'true'
        env:
          BOT_TOKEN: ${{ secrets.BOT_TOKEN }}
          CHAT_ID: ${{ secrets.CHAT_ID }}
        run: |
          TEXT="üîî F1 Eventim: bot√£o COMPRAR pode estar ATIVO!\nhttps://www.eventim.com.br/campaign/f1saopaulo"
          curl -sS --get "https://api.telegram.org/bot${BOT_TOKEN}/sendMessage" \
            --data-urlencode "chat_id=${CHAT_ID}" \
            --data-urlencode "text=${TEXT}"
